#!/usr/bin/env bash

# This script executes tests configured via a named pipe.
# The named pipe is written to by VIM commands.
# This is used for TDD.


# Terminology:
# - editors send "data" that describes the next test to run
# - this data contains amongst other things an "operation"
#   like "test_file_line" to test a file at a given line number
# - this server script parses the data into the full "command"
#   to run the test on the command line


VERSION=0.1

tput dim
echo -n "Tertestrial server "
tput setaf 6
echo $VERSION
tput sgr0
echo
case $(ps -o stat= -p $$) in

  *+*)
    # running in the foreground
    tput bold
    echo -n "ctrl-c "
    tput sgr0
    echo "to exit"
    ;;

  *)
    # running in the background
    #
    # Note: cannot use formatting here,
    # since we need to output this text as fast as possible.
    # Otherwise the output happens after the shell renders the next prompt
    echo "to exit, run 'fg', then hit [ctrl-c]"

esac



# GLOBAL VARIABLES

# The test command that was last run (example: "cucumber-js features/foo.feature:23")
last_test_command=''

# The operation to execute next (example: "test_file_line")
operation=''

# The file type that the editor thinks it has (example: "cucumber")
filetype=''

# The path of the file relative to the current directory (example: "features/foo.feature")
filename=''

# The line number in the file to run (example: "23")
line=''


# NAMED PIPE SETUP

# create the named pipe if it doesn't exist
if [ ! -p tertestrial ]; then
  mkfifo tertestrial
fi

# remove the pipe when the script ends
trap ctrl_c INT
function ctrl_c {
  echo
  echo
  echo "tertestrial shutting down..."
  rm tertestrial
  exit
}



# PARSE THE INCOMING DATA

# These functions determine the test command for particular combinations of input.
# They get called by determine_command_to_run.
function command_for_test_file_cucumber {
  echo "cucumber-js $filename"
}

function command_for_test_file_line_cucumber {
  echo "cucumber-js $filename:$line"
}

function command_for_repeat_last_test_ {
  echo $last_test_command
}

# Parses the data received from VIM
# into a set of global variables
function parse_data {
  operation=''
  filetype=''
  filename=''
  line=''
  eval "$1"
}

# Returns the exact command to run the next test
function determine_command_to_run {
  eval "command_for_${operation}_${filetype}"
}



# RUNNING TESTS

# Executes the current test command
function run_test {
  clear
  sh -c "$last_test_command"
}



# RECEIVING COMMANDS

# This function blocks until it receives the next command from the pipe,
# then returns that command
function receive_next_operation {
  cat tertestrial
}

while true; do
  data=$(receive_next_operation)
  parse_data "$data"
  last_test_command=$(determine_command_to_run)
  run_test
done
